<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Multi-party timestamping server</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN" crossorigin="anonymous"></script>
    <script src="https://cdn.adamhlavacek.com/GRenderer.js" crossorigin="anonymous"></script>
    <script>
        // check if debugging should be enabled (with possibly sensitive data)
        const DEBUG = localStorage.getItem('DEBUG') === '1';

        // TYPE definitions
        /** @typedef {{signature: string, timestamp: number, blinding: string}} Signature */
        /** @typedef {{ index: number, url: string, internalAddress: string }} StampServerLocation */
        /** @typedef {{ url: string, parties: StampServerLocation[] }} StampRequestParams */
        /** @typedef {{ hex: string, blinding: string, unixSeconds: number }} BlindedHash */

        /** @type {StampServerLocation[]} */
        const SERVERS = [
            {index: 1, url: 'http://localhost:8000', internalAddress: 'localhost:8000'},
            {index: 2, url: 'http://localhost:8001', internalAddress: 'localhost:8001'},
            {index: 3, url: 'http://localhost:8002', internalAddress: 'localhost:8002'},
        ];

        if (!DEBUG) {
            console.debug = () => {};
        }
        console.debug('[DEBUG]', 'Debugging is enabled');

        /**
         * Reorders servers in random order and pairs them
         * @return {StampRequestParams[]}
         */
        function getRandomServers() {
            /** @type StampRequestParams[] */
            let serverParams = [];

            // create all possible pairs
            SERVERS.forEach((server, index, array) => {
                for (let i = 0; i < array.length; i++) {
                    if (i === index) {
                        continue; // skip current index, cannot stamp with itself
                    }
                    // indexes are 1-based
                    serverParams.push({url: server.url, parties: [server, SERVERS[i]]});
                }
            });

            // reorder all pairs randomly
            /** @type StampRequestParams[] */
            let serversRandom = [];
            while (serverParams.length > 0) {
                serversRandom.push(...serverParams.splice(Math.floor(serverParams.length * Math.random()), 1));
            }

            return serversRandom;
        }

        /**
         * Attempts to timestamp a hash of a file with given server
         * @param server {string} url of the signing server
         * @param parties {StampServerLocation[]} other parties that are supposed to sign with this server
         * @param hash {BlindedHash} hash to be signed
         * @param timeout {number} maximal number of seconds to wait for server response
         * @return {Promise<Signature | null>}
         */
        async function stampSingle(server, parties, hash, timeout = 300) {
            console.debug('[STAMP]', server, parties, hash);
            // remove http(s):// from the address
            const partiesString = parties.map((p) => `${p.index},${p.internalAddress}`).join(',');
            /** @type Response */
            let response;
            try {
                response = await Promise.race([
                    fetch(`${server}/sign/2`, {
                        method: "POST",
                        cache: "no-cache",
                        credentials: "same-origin", // in case the backend is at same domain with basic auth reverse proxy
                        headers: {
                            "Content-Type": "text/plain",
                        },
                        body: `${partiesString},${hash.hex},${hash.unixSeconds}`,
                    }),
                    // reject the promise after timeout
                    new Promise((_, reject) => setTimeout(() => reject('Timeout'), timeout * 1000))
                ]);
            } catch (e) {
                console.debug('[STAMP]', 'Error', e);
                return null;
            }

            console.debug('[STAMP]', 'Response is OK?', response.ok);
            if (!response.ok) {
                return null;
            }

            const signature64 = await blobToBase64(await response.blob());
            return {
                signature: signature64,
                timestamp: hash.unixSeconds,
                blinding: hash.blinding
            };
        }

        /**
         * Attempts to timestamp a hash of a file with given parties
         * @param parties {StampServerLocation[]} other parties that are supposed to sign with this server
         * @param hash {BlindedHash} hash to be signed
         * @return {Promise<Blob | null>}
         */
        async function stamp(parties, hash) {
            const signatures = await Promise.all(
                    parties.map((party) => stampSingle(party.url, parties.filter(x => x !== party), hash))
            );
            console.debug('[STAMP]', 'result', signatures);
            if (signatures.find((r) => r === null) !== undefined) {
                console.debug('[STAMP]', 'at least one server has failed');
                return null;
            }

            if ((new Set(signatures.map((sig) => sig.signature))).size !== 1) {
                // all signatures must be the same
                console.debug('[STAMP]', 'signature mismatch');
                return null;
            }

            return new Blob([JSON.stringify(signatures[0])]);
        }

        /**
         * Converts arbitrary blob into base64 string
         * @param blob {Blob} blob to be converted
         * @return {Promise<string>} base64 representation of blob
         */
        async function blobToBase64(blob) {
            const reader = new FileReader();
            return new Promise((resolve) => {
                reader.addEventListener("load", () => {
                    const dataStartPrefix = ';base64,';
                    const dataStart = reader.result.indexOf(dataStartPrefix);
                    resolve(reader.result.substring(dataStart + dataStartPrefix.length));
                }, false);
                reader.readAsDataURL(blob);
            })
        }

        /**
         * Creates a SHA256 hash of a file with given timestamp and additional blinding data
         * @param file {Blob} file to be hashed
         * @param time {Date} the requested timestamp
         * @param randomData {Blob} additional data to be hashed
         * @return {Promise<BlindedHash>} hex-string of its SHA256 hash
         */
        async function sha256(file, time, randomData) {
            console.assert(file !== null);
            const fileData = await file.arrayBuffer();
            const unixSeconds = Math.floor(time.getTime() / 1000);
            const timeBlob = new Blob([`${unixSeconds}`]);

            const data = await new Blob([timeBlob, fileData, randomData]).arrayBuffer();

            // Adapted from https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest#converting_a_digest_to_a_hex_string
            const hashBuffer = await crypto.subtle.digest("SHA-256", data); // hash the message
            const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array
            const hexString = hashArray
                    .map((b) => b.toString(16).padStart(2, "0"))
                    .join("");
            return {
                hex: hexString,
                blinding: await blobToBase64(randomData),
                unixSeconds: unixSeconds
            }
        }

        /**
         * Generates a secure-random blob
         * @param length {number} length in bytes
         * @return {Blob} random blob
         */
        function randomBlob(length = 256) {
            const randomData = new Uint8Array(length);
            window.crypto.getRandomValues(randomData);
            return new Blob([randomData]);
        }

        /**
         * Sets new progressbar text, null for disabling progressbar
         * @param text {string | null}
         * @param percentage {number}
         */
        function setProgressbar(text, percentage) {
            const progressCurrent = _renderer.variables.progress || {};
            if (text === null) {
                progressCurrent.shown = false;
            } else {
                progressCurrent.shown = true;
                progressCurrent.text = text;
                progressCurrent.percentage = percentage;
            }

            _renderer.variables.progress = progressCurrent;
            _renderer.render();
        }

        /**
         * Shows an error message to the user
         * @param message {string | null} null hides the message
         */
        function showError(message) {
            _renderer.variables.error = message;
            _renderer.render();
        }

        /** @type {GRenderer | undefined} */
        let _renderer;

        window.onload = () => {
            /** @type {HTMLInputElement} */
            const inputFile = document.querySelector('#inputFile');
            console.assert(inputFile !== null);
            /** @type {HTMLFormElement} */
            const inputFileForm = document.querySelector('#inputFileForm');
            console.assert(inputFileForm !== null);
            /** @type {HTMLAnchorElement} */
            const btnDownloadStamp = document.querySelector('#btnDownloadStamp');
            console.assert(btnDownloadStamp !== null);

            /** @type {File | null} */
            let selectedFile;

            _renderer = new GRenderer(document.querySelector('body'), {
                selectDisabled: undefined,
                submitDisabled: true
            }, undefined, {
                onFileSelect: () => {
                    selectedFile = inputFile.files.item(0);
                    _renderer.variables.submitDisabled = selectedFile === null ? true : undefined;
                    _renderer.render();
                },
                onFormSubmit: async () => {
                    // disable next submitting
                    _renderer.variables.submitDisabled = true;
                    _renderer.variables.selectDisabled = true;
                    _renderer.variables.stamp = null;
                    showError(null);
                    _renderer.render();

                    setProgressbar('Computing file hash', 25);
                    /** @type {BlindedHash} */
                    let hash;
                    try {
                        hash = await sha256(selectedFile, new Date(), randomBlob());
                    } catch (e) {
                        showError('Could not hash given file');
                        console.error(e);
                        return;
                    }

                    let success = false;
                    const servers = getRandomServers();
                    for (let i = 0; i < servers.length; i++) {
                        const server = servers[i];
                        setProgressbar(`${i + 1}/${servers.length}: Asking ${server.parties.map(p => p.url).join(' & ')} to sign`, 50 + (25 * i / servers.length));
                        const timestamp = await stamp(server.parties, hash);
                        if (timestamp === null) {
                            continue;  // try next server, no single point of failure
                        }
                        setProgressbar(selectedFile.name + ' successfuly signed', 100);
                        _renderer.variables.stamp = {
                            url: URL.createObjectURL(timestamp),
                            filename: selectedFile.name + '.stamp'
                        };
                        btnDownloadStamp.download = _renderer.variables.stamp.filename;
                        btnDownloadStamp.href = _renderer.variables.stamp.url;
                        success = true;
                        break;
                    }

                    if (!success) {
                        showError('None of the servers responded in time, try again later');
                    }

                    _renderer.variables.submitDisabled = undefined;
                    _renderer.variables.selectDisabled = undefined;
                    _renderer.render();
                }
            });

            // handle UI events
            inputFile.onchange = _renderer.functions.onFileSelect;
            inputFileForm.onsubmit = (e) => {
                e.preventDefault();
                e.stopPropagation();
                _renderer.functions.onFormSubmit();
                return false;
            }
            // run first render
            _renderer.render();
        }
    </script>
</head>
<body>
<div class="container mt-3">
    <div class="row">
        <div class="col-12"><h1>Multi-party timestamping server</h1></div>
    </div>
    <div class="row">
        <form id="inputFileForm">
            <div class="mb-3">
                <label for="inputFile" class="form-label">File to timestamp</label>
                <input type="file" r-attr="{&quot;disabled&quot;: &quot;v.selectDisabled&quot;}" class="form-control" id="inputFile" aria-describedby="helpFile">
                <div id="helpFile" class="form-text">Hash of the file is computed locally and then sent to the server</div>
            </div>
            <button r-attr="{&quot;disabled&quot;: &quot;v.submitDisabled&quot;}" type="submit" class="btn btn-primary">Submit</button>
            <a r-if="v.stamp" id="btnDownloadStamp" class="btn btn-secondary">Download stamp</a>
        </form>
    </div>
    <div r-if="v.error" class="row mt-3">
        <div class="alert alert-danger" role="alert" r-var="v.error"></div>
    </div>
    <div r-if="v.progress.shown" class="row mt-3">
        <div class="progress" role="progressbar" aria-label="Animated striped example" aria-valuenow="75" aria-valuemin="0" aria-valuemax="100">
            <div class="progress-bar progress-bar-striped progress-bar-animated" r-attr="{&quot;style&quot;: &quot;'width: ' + v.progress.percentage + '%'&quot;}" r-var="v.progress.text"></div>
        </div>
    </div>
</div>
</body>
</html>
